"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1537],{20010(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>f,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=t(74848),o=t(28453);const s={title:"Coding Conventions"},a=void 0,r={id:"Coding-Conventions",title:"Coding Conventions",description:"While not all of Premake's code currently follows these conventions, we are gradually nudging everything in this direction and hope to have it all done before the final 5.0 release. Knowing these conventions will make the code a little easier to read and follow.",source:"@site/docs/Coding-Conventions.md",sourceDirName:".",slug:"/Coding-Conventions",permalink:"/docs/Coding-Conventions",draft:!1,unlisted:!1,editUrl:"https://github.com/premake/premake-core/edit/master/website/docs/Coding-Conventions.md",tags:[],version:"current",lastUpdatedBy:"Pete Forrest",lastUpdatedAt:1756192024e3,frontMatter:{title:"Coding Conventions"},sidebar:"docs",previous:{title:"Code Overview",permalink:"/docs/Code-Overview"},next:{title:"Overrides & Call Arrays",permalink:"/docs/Overrides-and-Call-Arrays"}},l={},c=[{value:"Tables as Namespaces",id:"tables-as-namespaces",level:3},{value:"Local Variables as Aliases",id:"local-variables-as-aliases",level:3},{value:"Call Arrays",id:"call-arrays",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"While not all of Premake's code currently follows these conventions, we are gradually nudging everything in this direction and hope to have it all done before the final 5.0 release. Knowing these conventions will make the code a little easier to read and follow."}),"\n",(0,i.jsx)(n.h3,{id:"tables-as-namespaces",children:"Tables as Namespaces"}),"\n",(0,i.jsxs)(n.p,{children:["Premake tables are used as namespaces, with related functions grouped together into their own namespace table. Most of Premake's own code is placed into a table named ",(0,i.jsx)(n.code,{children:"premake"}),". Code related to the project scripting API is in ",(0,i.jsx)(n.code,{children:"premake.api"}),", code related to command line options in in ",(0,i.jsx)(n.code,{children:"premake.options"}),", and so on."]}),"\n",(0,i.jsx)(n.p,{children:"Organizing the code in this way helps avoid collisions between similarly named functions, and generally helps to keep things tidy."}),"\n",(0,i.jsx)(n.h3,{id:"local-variables-as-aliases",children:"Local Variables as Aliases"}),"\n",(0,i.jsx)(n.p,{children:"New namespaces are declared at the top of each source code file, followed by aliases for namespaces which are going to be used frequently within the source file. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- define a new namespace for the VC 2010 related code\npremake.vstudio.vc2010 = {}\n\n-- create aliases for namespaces we\'ll use often\nlocal p = premake\nlocal vstudio = p.vstudio\nlocal project = p.project\n\n-- and the "m" alias represents the current module being implemented\nlocal m = p.vstudio.vc2010\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The alias ",(0,i.jsx)(n.code,{children:"p"})," is used conventionally  as a shortcut for the ",(0,i.jsx)(n.code,{children:"premake"})," namespace. The alias ",(0,i.jsx)(n.code,{children:"m"})," is conventionally used to represent the module being implemented."]}),"\n",(0,i.jsx)(n.p,{children:"Using aliases saves some keystrokes when coding. And since Premake embeds all of its scripts into the release executables, it saves on the final download size as well."}),"\n",(0,i.jsx)(n.h3,{id:"call-arrays",children:"Call Arrays"}),"\n",(0,i.jsx)(n.p,{children:'Premake\'s project file exporters\u2014which write out the Visual Studio projects, makefiles, and so on\u2014are basically big long lists of "output this, and then this, and then this". This could easily be written (and once was) as one giant function, but then it would be virtually impossible to modify its behavior.'}),"\n",(0,i.jsx)(n.p,{children:"Instead, we split up the generation of a project into many small functions, often writing out only a single line to the output. Any one of these functions can then be overridden by your own scripts or modules."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:'-- instead of this...\n\n\tfunction m.outputConfig(cfg)\n\t\tif #cfg.defines > 0 or vstudio.isMakefile(cfg) then\n\t\t\tp.x(\'PreprocessorDefinitions="%s"\', table.concat(cfg.defines, ";"))\n\t\tend\n\n\t\tif #cfg.undefines > 0 then\n\t\t\tp.x(\'UndefinePreprocessorDefinitions="%s"\', table.concat(cfg.undefines, ";"))\n\t\tend\n\n\t\tif cfg.rtti == p.OFF and cfg.clr == p.OFF then\n\t\t\tp.w(\'RuntimeTypeInfo="false"\')\n\t\telseif cfg.rtti == p.ON then\n\t\t\tp.w(\'RuntimeTypeInfo="true"\')\n\t\tend\n\tend\n\n-- we do this...\n\n\tfunction m.preprocessorDefinitions(cfg)\n\t\tif #cfg.defines > 0 or vstudio.isMakefile(cfg) then\n\t\t\tp.x(\'PreprocessorDefinitions="%s"\', table.concat(cfg.defines, ";"))\n\t\tend\n\tend\n\n\tfunction m.undefinePreprocessorDefinitions(cfg)\n\t\tif #cfg.undefines > 0 then\n\t\t\tp.x(\'UndefinePreprocessorDefinitions="%s"\', table.concat(cfg.undefines, ";"))\n\t\tend\n\tend\n\n\tfunction m.runtimeTypeInfo(cfg)\n\t\tif cfg.rtti == p.OFF and cfg.clr == p.OFF then\n\t\t\tp.w(\'RuntimeTypeInfo="false"\')\n\t\telseif cfg.rtti == p.ON then\n\t\t\tp.w(\'RuntimeTypeInfo="true"\')\n\t\tend\n\tend\n\n'})}),"\n",(0,i.jsx)(n.p,{children:'Similarly, instead of implementing the output of a particular section of the project as a function calling a long list of other functions, we put those functions into an array, and then iterate over the array. We call these "call arrays", and they allow you to inject new functions, or remove existing ones, from the array at runtime.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",children:"-- instead of this...\n\n\tfunction m.outputConfig(cfg)\n\t\tm.preprocessorDefinitions(cfg)\n\t\tm.undefinePreprocessorDefinitions(cfg)\n\t\tm.runtimeTypeInfo(cfg)\n\t\t-- and so on...\n\tend\n\n-- we do this\n\n\tm.elements.config = function(cfg)\n\t\treturn {\n\t\t\tm.preprocessorDefinitions,\n\t\t\tm.undefinePreprocessorDefinitions,\n\t\t\tm.runtimeTypeInfo,\n\t\t\t-- and so on...\n\t\t}\n\tend\n\n\tfunction m.outputConfig(cfg)\n\t\tp.callArray(m.element.config, cfg)\n\tend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For an example of how to implement a new feature using these conventions, see ",(0,i.jsx)(n.a,{href:"/docs/Overrides-and-Call-Arrays",children:"Overrides and Call Arrays"}),"."]})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);